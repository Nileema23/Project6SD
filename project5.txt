'''
Implement a Double Array Queue and test it for a very large case (100,000 randomly decided
operations of enqueue or dequeue)
Your program should compute the number of costly operations and cheap operations
Your program should also ask the user about the ratio between enqueue and dequeue operations:
The probability of enqueues and dequeues should never be of less than half enqueues than dequeues (33% enqueues - 67%)
The probability of enqueues and dequeues should never be of less than half dequeues than enqueues (67% enqueues - 33%)'''

#Import randrange 
from random import randrange
#Defining class as Double_queue.
class Double_Queue:

    #Initializing constructor.
    def __init__(self):
        self.a_in = []
        self.a_out = []

    #Item added to the start of an array.
    def add_item_start(self,data):
        self.a_in.append(data)
    
    #item added to the end of an array.
    def add_item_end(self,data):
        self.a_out.append(data)

    #Remove and return from first item from the input array.
    def remove_item_start(self):
        if self.is_empty():
            return None
        return self.a_in.pop(0)

    #Remove and return from first item from the output array.
    def remove_item_end(self):
        if self.is_empty():
            return None
        #if output array is empty,add items from input array to output array.
        else:
            for d in self.a_in:
                self.a_out.append(d)
            self.a_in = []
        return self.a_out.pop(0)#remove and return the first item from output array.

    #Check if queue is empty.
    def is_empty(self):
        return len(self.a_in) == 0 and len(self.a_out) == 0
    
    #check if output array is empty.
    def is_out_empty(self):
        return len(self.a_out) == 0


#Define test()with three parameter.
def test(initialSize,enqueue,dequeue):
    #Initialize acccheap, accCostly with 0 ot track number of cheap and costly operation.
    accCheap, accCostly, cheap2, cheap3 = 0, 0,0 ,0
    s = initialSize #Logical size of an array
    m = 2*s         #Double the size of queue to twicw the initial size.

    #looping to perform 100,000 operations.
    for i in range(100000):
        a= randrange(100)
        if (a < (enqueue/(enqueue+dequeue))* 100):  #Case 1: Removing an element from array.  
            if (s == m):       #If allocated memory is full increase costly operation count.
                m = m*2
                q.add_item_start(i)                
                accCostly += 1 
            else:
                q.add_item_start(i)            #If allocated memory is not full increase cheap operation count.         
                accCheap += 1
            s += 1
        else:
            if (s > 0):
                q.remove_item_end()
                accCheap += 1
                s -= 1
                cheap2 += 1
                
    #print("Initial size:", initialSize, "Prob Remove:", , "out of 100")
    print("Costly: {:7} ({:3.1}%)".format(accCostly,100*accCostly/(accCostly+accCheap)))
    print("Cheap: {:7} ({:3.1}%)".format(accCheap,100*accCheap/(accCostly+accCheap)))
    print("cheap2: ", cheap2)
    print("cheap3: ", cheap3)

        

q = Double_Queue()
    #Main function where test()is called with different inputs.
def main():
    for i in range(5):
        while True:
            enq_p =67
            deq_p =33

            if enq_p +deq_p >100:
                print("invalid %")

            elif(enq_p <35) or (enq_p>67) or (deq_p<33) or (deq_p>67):
                print("invalid should between 33 and 67 ")
            else:
                enq_ratio = int(enq_p/(100-enq_p)+0.5)
                deq_ratio = int(deq_p/(100-enq_p)+0.5)
                if enq_ratio >=deq_ratio *2 or deq_ratio >= enq_ratio*2:
                    break
                else:
                    print("invalid ratios")
        print("run",i)              
        test(10,enq_ratio,deq_ratio)
        #test(10,55,45)
        #test(10,40,60)
                
    
main()



    


